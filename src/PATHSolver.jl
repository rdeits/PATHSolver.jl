module PATHSolver

using ForwardDiff

if isfile(joinpath(dirname(dirname(@__FILE__)), "deps", "deps.jl"))
  include(joinpath(dirname(dirname(@__FILE__)), "deps", "deps.jl"))
else
  error("PATHSolver not properly installed. Please run Pkg.build(\"PATHSolver\")")
end




export solveMCP, options

count_nonzeros(M::AbstractSparseMatrix) = nnz(M)
count_nonzeros(M::AbstractMatrix) = count(x -> !iszero(x), M)  # fallback for dense matrices


function solveMCP(f_eval::Function, lb::Vector, ub::Vector, var_name=C_NULL, con_name=C_NULL)
  j_eval = x -> ForwardDiff.jacobian(f_eval, x)
  return solveMCP(f_eval, j_eval, lb, ub, var_name, con_name)
end

function solveMCP(f_eval::Function, j_eval::Function, lb::Vector, ub::Vector, var_name=C_NULL, con_name=C_NULL)
  f_user_cb = cfunction(f_user_wrap(f_eval), Cint, (Cint, Ptr{Cdouble}, Ptr{Cdouble}))
  j_user_cb = cfunction(j_user_wrap(j_eval), Cint, (Cint, Cint, Ptr{Cdouble}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}, Ptr{Cdouble}))

  n = length(lb)
  z = copy(lb)
  f = zeros(n)

  J0 = j_eval(z)
  nnz = count_nonzeros(J0)

  t = ccall( (:path_main, "libpath47julia"), Cint,
          (Cint, Cint,
           Ptr{Cdouble}, Ptr{Cdouble},
           Ptr{Cdouble}, Ptr{Cdouble},
           Ptr{Ptr{Cchar}}, Ptr{Ptr{Cchar}},
           Ptr{Void}, Ptr{Void}),
           n, nnz, z, f, lb, ub, var_name, con_name, f_user_cb, j_user_cb)

  status =
   [  :Solved,                          # 1 - solved
      :StationaryPointFound,            # 2 - stationary point found
      :MajorIterationLimit,             # 3 - major iteration limit
      :CumulativeMinorIterationLimit,   # 4 - cumulative minor iteration limit
      :TimeLimit,                       # 5 - time limit
      :UserInterrupt,                   # 6 - user interrupt
      :BoundError,                      # 7 - bound error (lb is not less than ub)
      :DomainError,                     # 8 - domain error (could not find a starting point)
      :InternalError                    # 9 - internal error
  ]

  remove_option_file()
  return status[t], z, f

end



function remove_option_file()
  if isfile("path.opt")
    rm("path.opt")
  end
end

function options(;kwargs...)
  opt_file = open("path.opt", "w")
  println(opt_file, "* Generated by PATHSolver.jl. Do not edit.")
  for (key, value) in kwargs
    println(opt_file, key, " ", value)
  end
  close(opt_file)
end


###############################################################################
# wrappers for callback functions
###############################################################################
# static int (*f_eval)(int n, double *z, double *f);
# static int (*j_eval)(int n, int nnz, double *z, int *col_start, int *col_len,
      # int *row, double *data);

function f_user_wrap(user_f::Function)
  function callback(n::Cint, z_ptr::Ptr{Cdouble}, f_ptr::Ptr{Cdouble})
    z = unsafe_wrap(Array{Cdouble}, z_ptr, Int(n), false)
    f = unsafe_wrap(Array{Cdouble}, f_ptr, Int(n), false)
    f .= user_f(z)
    return Cint(0)
  end
  return callback
end

function j_user_wrap(user_j::Function)
  function callback(n::Cint, expected_nnz::Cint, z_ptr::Ptr{Cdouble},
                    col_start_ptr::Ptr{Cint}, col_len_ptr::Ptr{Cint}, 
                    row_ptr::Ptr{Cint}, data_ptr::Ptr{Cdouble})

    z = unsafe_wrap(Array{Cdouble}, z_ptr, Int(n), false)
    J = user_j(z)

    # Convert the user-supplied jacobian into the sparse format expected by
    # PATH. Fortunately, PATH just wants a compressed-sparse-column format, 
    # which is exactly what Julia's default SparseMatrixCSC uses
    J_csc = convert(SparseMatrixCSC, J) 
    if nnz(J_csc) > expected_nnz
      error("Evaluated jacobian has more nonzero entries than were initially provided in solveMCP()")
    end

    # col_start in PATH corresponds to J_csc.colptr[1:end-1]
    col_start = unsafe_wrap(Array{Cint}, col_start_ptr, Int(n), false)
    # col_len in PATH corresponds to diff(J_csc.colptr)
    col_len = unsafe_wrap(Array{Cint}, col_len_ptr, Int(n), false)
    # row in PATH corresponds to rowvals(J_csc)
    row = unsafe_wrap(Array{Cint}, row_ptr, Int(expected_nnz), false)
    # data in PATH corresponds to nonzeros(J_csc)
    data = unsafe_wrap(Array{Cdouble}, data_ptr, Int(expected_nnz), false)

    for i in 1:n
      col_start[i] = J_csc.colptr[i]
      col_len[i] = J_csc.colptr[i + 1] - J_csc.colptr[i]
    end

    rv = rowvals(J_csc)
    nz = nonzeros(J_csc)
    for i in 1:nnz(J_csc)
      row[i] = rv[i]
      data[i] = nz[i]
    end
    for i in (nnz(J_csc)+1):expected_nnz
      row[i] = 1
      data[i] = 0
    end
    return Cint(0)
  end
  return callback
end
###############################################################################

end # Module
